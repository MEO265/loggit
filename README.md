---
title: "Effortless Exception Logging in R"
author: "Ryan Price <ryapric@gmail.com>"
date: "2018-02-12"
output:
  html_document:
    keep_md: TRUE
---



This package is designed for anyone whow has written their own package or
analysis functions that already use basic exception handling by way of base R's
`message()`, `warning()`, and `stop()`. The loggit package *masks* base R's
versions of these functions, but slots in a logging function (`loggit()`) just
before the exception handler executes. Since these functions maintains
identical functionality to their base equivalents, there is no need for any
change in your existing code, if you have already written handlers. Just
install & load `loggit`, and instantly have your exceptions recorded (by
default, to a [JSON](https://www.json.org/) file in your working directory).

This package was inspired by a colleague's suggestion of how we could log our
ETL workflow results in R, as well as the
[rlogging](https://github.com/mjkallen/rlogging) package. When we looked at how
`rlogging` was doing this, we felt that we could expand upon it and make it
more flexible, system-portable, and with even less user effort. As opposed to
other packages like [log4r](http://cran.r-project.org/package=log4r),
[futile.logger](http://cran.r-project.org/package=futile.logger) and
[logging](http://cran.r-project.org/package=logging), which may allow for more
powerful logs in some cases, we wanted to make great logging "out of sight, out
of mind"; at least until your boss asks for those ETL logs!

<br>

### Features

R has a selection of built-in functions for handling different *exceptions*, or
special cases where diagnostic messages are provided, and/or function execution
is halted because of an error. However, R itself provides nothing to record
this diagnostic post-hoc; useRs are left with what is printed to the console as
their only means of analyzing the what-went-wrong of their code. There are some
slightly hacky ways of capturing this console output, such as `sink`ing to a
text file, repetitively `cat`ing identical exception messages that are passed
to existing handler calls, etc. But there are two main issues with these
approaches:

1. The console output is not at all easy to parse, so that a user can quickly
identify the causes of failure without manually scanning through it

2. Even if the user tries to structure a text file output, they would likely
have to ensure consistency in that output across all their work, and there is
still the issue of parsing that text file into a faimliar, usable format

Enter: [JSON](https://www.json.org/)

JSON is a lightweight, portable (standardized) data format that is easy to read
and write by both humans and machines. An excerpt from the introduction of the
JSON link above:

"JSON (JavaScript Object Notation) is a lightweight data-interchange format. It
is easy for humans to read and write. It is easy for machines to parse and
generate. It is based on a subset of the JavaScript Programming Language,
Standard ECMA-262 3rd Edition - December 1999. JSON is a text format that is
completely language independent but uses conventions that are familiar to
programmers of the C-family of languages, including C, C++, C#, Java,
JavaScript, Perl, Python, and many others. These properties make JSON an ideal
data-interchange language."

Basically, you can think of JSON objects like you would think of `list`s in R:
a set of key-value pairs, with the option to nest lists within other lists.
This makes JSON not only as powerful as R's lists, but it allows this
nested-list functionality to be translated to other software, and let them
handle them just as easily! As such, JSON is the default log file output type
in the `loggit` package.

<br>

### How to Use

Chances are that if you've read this far, you're familiar with R's exception
handlers. If so, then the only other thing you need to know is that the log
file is output to your current working directory, named `loggit.json`, and you
can review it there:

* `timestamp`: when the exception was raised
* `log_lvl`: the "level" of the exception (INFO, WARN, or ERROR)
* `log_msg`: the diagnotic message generated by R
* `log_detail`: additional exception details you can pass to `warning()` and
    `stop()`, though not necessary to supply.

That's it!

However, if you care a bit more about the details or want more control:

* You can control the output name & location of the log file using
    `setLogFile(logfile, folder)`. `loggit` *will not* write to disk unless a exception
    is raised, but you should specify this change early, if desired. You can see the
    current log file path at package attachment, or by calling `getLogFile()`.
* You can control the format of the timestamp in the logs; it defaults to ISO
    format `"%Y-%m-%d %H:%M:%S"`, but you may set it yourself using
    `setTimestampFormat()`. Note that this format is passed to `format.Date()`,
    so the supplied format needs to be valid.
* While this package automatically masks the base handlers, the `loggit` function
    that they call is also exported for use, if so desired. It is called as:
    `loggit(log_lvl, log_msg, log_detail)`, so you can log arbitrary things as
    much or as little as you see fit.
* If for any reason you do not want to log the output to a log file, you can
    set each handler's `.loggit` argument to `FALSE`. This will eventually be a
    global option that the user can set, and leave the handlers without the
    argument.

<br>

### Note on *What* Gets Logged

Note that this package does not mask the handler functions included in *other*
packages, _**including in base R**_; for example, running the following will
throw an error as usual, but *will not* write to the log file:

    > 2 + "a"
    Error in 2 + "a" : non-numeric argument to binary operator
    > dplyr::left_join(data.frame(a = 1), data.frame(b = 2))
    Error: `by` required, because the data sources have no common variables
    > # Did loggit write these exception messages to the logfile?
    > file.exists(loggit:::.config$logfile)
    [1] FALSE

This is integral to how R works with packages, and is by design; it has to do
with [namespaces](http://r-pkgs.had.co.nz/namespace.html), which is how R looks
for *what* to do when you ask it to do something. Basically, if a package you
use doesn't have `loggit` in its `NAMESPACE` file, then its internal exception
handlers won't be masked by `loggit`.

If you really wish to have *all* exception messages logged by `loggit`, you can
learn how to do this... _**but not from a Jedi**_.

This package includes the `loggitall()` function, which works by creating
temporary `NAMESPACE` files for packages supplied as arguments. These
`NAMESPACE` files simply have `loggit` appended to the end. Being a relatively
spooky function, you can only call `loggitall()` from what I like to call "deep
namespacing", i.e. `loggit:::loggitall(pkgs)` (note the three colons).

If you want to revert the modified `NAMESPACE` files to their original states,
for any reason, just call `loggit:::stoppitall()` (three colons, two P's). This
function takes no arguments, and will restore the old `NAMESPACE`s, even if
used in a different R session. It works by tracking which packages have ever
been edited, and applying fixes retroactively.

Before you go around messing with source code, though, please read through the
excellent [book by Hadley Wickham on R package
development](http://r-pkgs.had.co.nz/). It's relatively short, and written
quite well.

_**NOTE**_: While they work as intended on a file system level, none of the
above functions are actually masking the functions right now, so disregard
until they work as intended.

<br>

### Installation

  Via [devtools](https://github.com/hadley/devtools):

    devtools::install_github("ryapric/loggit")

  Or, clone & build from source:

    git clone https://github.com/ryapric/loggit.git
    R CMD INSTALL loggit

To use the most recent development version of `loggit` in your own package, you
can include it in your `Remotes:` field in your DESCRIPTION file:

    Remotes: github::ryapric/loggit

Note that packages being submitted to CRAN *cannot* have a `Remotes` field.
Refer
[here](https://cran.r-project.org/web/packages/devtools/vignettes/dependencies.html)
for more info.

<br>

### License

GPL-3
